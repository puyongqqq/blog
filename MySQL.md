### MySQL基础总结

#### 1. MyISAM 和 InnoDB的区别

|           | MyISAM                                   | InnoDB                |
| --------- | ---------------------------------------- | --------------------- |
| 事务      | 不支持                                   | 支持                  |
| 外键      | 不支持                                   | 支持                  |
| 索引类型  | 非聚集索引                               | 聚集索引              |
| 锁粒度    | 表锁                                     | 行锁                  |
| count函数 | 会给每张表维护一个count字段（不加where） | 慢（全表扫描）        |
| 其他      | 5.5之前默认存储引擎                      | 5.5之后的默认存储引擎 |

MyISAM常作为`SELECT`较多时的一种数据库存储引擎，不支持事务，不支持外键，非聚集索引，内部会为维护表的一个count值。每张表在磁盘上存储成三个文件。`.frm`文件存储表定义，`.myd`文件存储元数据，`.myi`文件存储索引数据。因为是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的，默认表锁，所以并发读也低。

InnoDB因其支持事务和行锁，并发性能高，在MySQL5.5被作为其默认的存储引擎。主键索引默认为聚集索引。InnoDB还支持`redo log`，对数据完整性也是可保障的（`crash-safe`）。

> 默认情况下，InnoDB存储引擎不会回滚超时引发的异常，除死锁外。

#### 2. 锁的分类

> 锁和触发器，其实都是基于索引实现的。都是为了实现快速筛选符合条件的数据行，而快速筛选，则是通过索引实现。

1. 记录锁（Record Locks）。（RD，RR）

   锁直接加在索引记录上面（无索引项时演变成**表锁**）。

2. 间隙锁（Gap Locks）。（RR）

   锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别的。

3. 行间锁（Next-Key Locks）。（RR）

   对记录锁和间隙锁的组合，既锁住行也锁住间隙。并且采用的左开右闭`(x, y]`的原则，InnoDB 对于查询都是采用这种锁的。其解决了**幻读**。

4. 表锁。

   表锁就是将一整张表加锁，在表被锁定期间，其他事务不能对该表进行更新操作，必须等当前表的锁被释放后才能进行操作。

#### 3. MVCC和Read View

> MVCC只在已提交读和可重复读两个隔离级别下生效。因为，未提交读，永远拿到的都是表中最新的数据，这个快照也就没有意义。而串行化，所有的事务，串行执行，不存在并发访问数据，所以也就不需要这个快照。
>
> Read VIew可以理解为数据在某一时刻的一份内存快照，MVCC维护了多个Read View，而每个事务只对应一个Read View。

多版本并发控制。是一种数据库并发控制的方法。它是通过保存数据在某个时间点的快照来实现，这意味着一个事务在开始和结束看到的数据是相同的，不同事务看到的数据可能是不同的。**MVCC是通过在每行记录后面保存两个隐藏的列来实现的。一个是事务id（trx_id），一个是回滚指针（roll_pointer）。**在每个事务开始时，会生成一个全局自增的一个事务id，修改某行记录时，都会把该事务的事务id赋值给`trx_id`隐藏列，把`undo`日志地址赋值给`roll_pointer`隐藏列。

由于每次变动都会先把`undo`日志记录下来，并用`roll_pointer`指向`undo`日志地址。因此可以认为，**对该条记录的修改日志串联起来就形成了一个`版本链`，版本链的头节点就是当前记录最新的值**。

什么是快照度和当前读。

> 快照度，读取MVCC中的数据，多个事务中读取的数据可能存在不一致。`select`默认加读取快照中的数据。
>
> 当前读，对于更新操作，默认采用当前读取，即读取表中的当前数据。多个事务并发操作只会有一个事务更新成功，其他事务会阻塞。（被修改的行被加排它锁，具体是行锁还是表锁，根据where条件来确定。更新超时数据不会回滚）

什么时候创建Read View。

> RR级别下，事务中的第一个SELECT请求才开始创建read view；
> RC级别下，事务中每次SELECT请求都会重新创建read view；

#### 4. 一条update语句的执行过程

> 单条更新语句的执行，Innodb默认会以事务方式执行。

#### 5. 几种日志的关系及作用



#### 6. Buffer Pool



#### 7. 索引失效场景



#### 8. 主备延迟问题及解决
