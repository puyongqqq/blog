### MySQL基础总结

#### 1. MyISAM 和 InnoDB的区别

|           | MyISAM                                   | InnoDB                |
| --------- | ---------------------------------------- | --------------------- |
| 事务      | 不支持                                   | 支持                  |
| 外键      | 不支持                                   | 支持                  |
| 索引类型  | 非聚集索引                               | 聚集索引              |
| 锁粒度    | 表锁                                     | 行锁                  |
| count函数 | 会给每张表维护一个count字段（不加where） | 慢（全表扫描）        |
| 其他      | 5.5之前默认存储引擎                      | 5.5之后的默认存储引擎 |

MyISAM常作为`SELECT`较多时的一种数据库存储引擎，不支持事务，不支持外键，非聚集索引，内部会为维护表的一个count值。每张表在磁盘上存储成三个文件。`.frm`文件存储表定义，`.myd`文件存储元数据，`.myi`文件存储索引数据。因为是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的，默认表锁，所以并发读也低。

InnoDB因其支持事务和行锁，并发性能高，在MySQL5.5被作为其默认的存储引擎。主键索引默认为聚集索引。InnoDB还支持`redo log`，对数据完整性也是可保障的（`crash-safe`）。

> 默认情况下，InnoDB存储引擎不会回滚超时引发的异常，除死锁外。

#### 2. 锁的分类

> 锁和触发器，其实都是基于索引实现的。都是为了实现快速筛选符合条件的数据行，而快速筛选，则是通过索引实现。

1. 记录锁（Record Locks）。（RD，RR）

   锁直接加在索引记录上面（无索引项时演变成**表锁**）。

2. 间隙锁（Gap Locks）。（RR）

   锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别的。

3. 行间锁（Next-Key Locks）。（RR）

   对记录锁和间隙锁的组合，既锁住行也锁住间隙。并且采用的左开右闭`(x, y]`的原则，InnoDB 对于查询都是采用这种锁的。其解决了**幻读**。

4. 表锁。

   表锁就是将一整张表加锁，在表被锁定期间，其他事务不能对该表进行更新操作，必须等当前表的锁被释放后才能进行操作。

#### 3. MVCC和Read View

> MVCC只在已提交读和可重复读两个隔离级别下生效。因为，未提交读，永远拿到的都是表中最新的数据，这个快照也就没有意义。而串行化，所有的事务，串行执行，不存在并发访问数据，所以也就不需要这个快照。
>
> Read VIew可以理解为数据在某一时刻的一份内存快照，MVCC维护了多个Read View，而每个事务只对应一个Read View。

多版本并发控制。是一种数据库并发控制的方法。它是通过保存数据在某个时间点的快照来实现，这意味着一个事务在开始和结束看到的数据是相同的，不同事务看到的数据可能是不同的。**MVCC是通过在每行记录后面保存两个隐藏的列来实现的。一个是事务id（trx_id），一个是回滚指针（roll_pointer）。**在每个事务开始时，会生成一个全局自增的一个事务id，修改某行记录时，都会把该事务的事务id赋值给`trx_id`隐藏列，把`undo`日志地址赋值给`roll_pointer`隐藏列。

由于每次变动都会先把`undo`日志记录下来，并用`roll_pointer`指向`undo`日志地址。因此可以认为，**对该条记录的修改日志串联起来就形成了一个`版本链`，版本链的头节点就是当前记录最新的值**。

什么是快照度和当前读。

> 快照度，读取MVCC中的数据，多个事务中读取的数据可能存在不一致。`select`默认加读取快照中的数据。
>
> 当前读，对于更新操作，默认采用当前读取，即读取表中的当前数据。多个事务并发操作只会有一个事务更新成功，其他事务会阻塞。（被修改的行被加排它锁，具体是行锁还是表锁，根据where条件来确定。更新超时数据不会回滚）

什么时候创建Read View。

> RR级别下，事务中的第一个SELECT请求才开始创建read view；
> RC级别下，事务中每次SELECT请求都会重新创建read view；

#### 4. 一条update语句的执行过程

> 单条更新语句的执行，Innodb默认会以事务方式执行。

#### 5. 几种日志的关系及作用

1. Redo log。重做日志。模拟事务操作，记录事务修改操作。
2. Undo log。回滚日志。记录事务开始前，数据的原始信息。
3. Bin log。归档日志。保证数据一致性。
4. Slow log。慢日志。分析SQL执行慢的问题。

#### 6. Buffer Pool

由于磁盘随机读写的效率很低，MySQL为了提供性能，读写不是直接操作的磁盘文件，而是在内存中开辟了一个叫做Buffer pool的缓存区域，更新数据的时候会优先更新到Buffer pool，之后再由I/O线程写入磁盘。同时为了InnoDB为了保证宕机不丢失Buffer pool中的数据，实现crash safe，还引入了一个叫做redo log的日志模块。另外还有处于MySQL Server层的用于备份磁盘数据的bin log，用于事务回滚和MVCC的undo log等。

Buffer Pool Instance是MySQL缓冲池（Buffer Pool）的一个具体实例，通常在服务器内存小于1G时，只会创建一个实例。每个都有自己的锁，信号量，物理块(Buffer chunks)以及逻辑链表(List)。即各个instance之间没有竞争关系，可以并发读取与写入。所有instance的物理块(Buffer chunks)在数据库启动的时候被分配，直到数据库关闭内存才予以释放。

缓冲池中的数据按页`Page`存取，一页大小默认16K。主要存储**索引页**、**数据页**、**undo页**、**插入缓冲**（insert buffer)、**自适应哈希索引**（adaptive hash index)、**InnoDB存储的锁信息**（lock info)、**数据字典信息**（data dictionary)等。Buffer Pool 是按照Page大小来分配，受innodb_page_size控制。

##### 1. 三种Page

1. Free Page（**空闲页**）

   此Page 未被使用，位于 Free 链表

2. Clean Page（**干净页**）

   此Page 已被使用，但是页面未发生修改，位于LRU 链表。

3. Dirty Page（**脏页**）

   此Page 已被使用，页面已经被修改，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该Page 就变成了干净页。脏页 同时存在于LRU 链表和Flush 链表。

##### 2. 三种链表
1. LRU 链表

   采用**LRU算法**思想，**最近最少使用**的会被淘汰。链表被分成**两部分**，一部分是**New Sublist(Young 链表)**，用来存放**热数据**，默认占**5/8**，另外一部分是**Old Sublist(Old 链表)**，用来存放第一次进入LRU或者从热数据区域淘汰的页面，默认占**3/8**。**热数据区域的尾结点链接冷数据的头结点**。主要是为了预读的数据页和全表扫描污染Buffer pool。

   频繁访问一个Buffer Pool的页面，会促使页面往Young链表的头部移动。如果一个Page在被读到Buffer Pool后很快就被访问，那么该Page会往Young List的头部移动，但是如果一个页面是通过预读的方式读到Buffer Pool，且之后短时间内没有被访问，那么很可能在下次访问之前就被移动到Old List的尾部，而被驱逐了。

   > 优化点：
   >
   > 如果一个数据页已经处于Young 链表，当它再次被访问的时候，只有当其处于Young 链表长度的1/4(大约值)之后，才会被移动到Young 链表的头部。避免在热数据区域页面频繁调整在链表中的位置。

2. Flush 链表

   Flush 链表里面保存的都是**脏页**，这些脏页也会存在于LRU 链表。如果当前页面已经是脏页，就不需要再次加入Flush list，否则是第一次修改，需要加入Flush 链表。当Page Cleaner线程执行flush操作的时候，从尾部开始scan，将一定的脏页写入磁盘，推进检查点，减少recover的时间。

3. Free 链表

   Free 链表 存放的是**空闲页面**，初始化的时候申请一定数量的页面。

   在执行SQL的过程中，每次成功load 页面到内存后，会判断Free 链表的页面是否够用。如果不够用的话，就flush LRU 链表和Flush 链表来释放空闲页。如果够用，就从Free 链表里面删除对应的页面，在LRU 链表增加页面，保持总数不变。

   > 疑问：如果数据在缓冲区放不下时，会发生什么？

缓冲预读。

​	MySQL在读取数据的时候，会将查询到的数据按物理页取出，并将其加入到LRU List中。他还会异步的将后续的页面也读取到LRU List中。

预读失效。

​	由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。

​	解决：

（1）将LRU分为两个部分：

- 新生代(new sublist)
- 老生代(old sublist)

（2）新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)；

（3）新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：

- 如果数据真正被读取（预读成功），才会加入到新生代的头部
- 如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池

缓冲污染。

​	当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。

​	解决：

​	MySQL缓冲池加入了一个“**老生代停留时间窗口**”的机制：

- 假设T=老生代停留时间窗口；
- 插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部；
- 只有**满足**“被访问”并且“在老生代停留时间”大于T，才会被放入新生代头部；

##### 3. 数据页访问机制

1. **当访问的页面在缓存池中命中，则直接从缓冲池中访问该页面**。另外为了避免查询数据页时扫描LRU，还为每个buffer pool instance维护了一个**page hash**，通过space id和page no可以直接找到对应的page。一般情况下，当我们需要读入一个Page时，首先根据space id和page no找到对应的buffer pool instance。然后查询page hash，如果page hash中没有，则表示需要从磁盘读取。
2. 如果没有命中，则需要将这个页面**从磁盘上加载到缓存池中**，因此需要在缓存池中的空闲列表中找一个空闲的内存块来缓存这个从磁盘读入的页面。
3. 但存在空闲内存块被使用完的情况，不保证一定有空闲的内存块。假如空闲列表为空，没有空闲的内存块，则需要想办法去产生空闲的内存块。
4. **首先去LRU列表中找可以替换的内存页面**，查找方向是从列表的**尾部**开始找，如果找到可以替换的页面，将其**从LRU列表中摘除，加入空闲列表**，然后再去空闲列表中找空闲的内存块。第一次查找最多只扫描100个页面，循环进行到第二次时，会查找深度就是整个LRU列表。这就是LRU列表中的页面淘汰机制。
5. 如果在LRU列表中没有找到可以替换的页，则进行**单页刷新**，将脏页刷新到磁盘之后，然后将释放的内存块加入到空闲列表。然后再去空闲列表中取。为什么只做单页刷新呢？因为这个函数的目的是获取空闲内存页，进行脏页刷新是不得已而为之，所以只会进行一个页面的刷新，目的是为了尽快的获取空闲内存块。

##### 4. 脏页刷盘时机

1. **REDO日志快用满的时候**。由于MySQL更新是先写REDO日志，后面再将数据Flush到磁盘，如果REDO日志对应脏数据还没有刷新到磁盘就被覆盖的话，万一发生Crash，数据就无法恢复了。此时会从Flush 链表里面选取脏页，进行Flush。
2. **页面加载到缓冲池时**。Page Cleaner线程会从LRU 链表尾部淘汰一部分页面作为空闲页。如果对应的页面是脏页的话，就需要先将页面Flush到磁盘。
3. **MySQL中脏页太多的时候**。当最大脏页比例超过阈值（默认75%）时，会触发强制刷脏页，从而保证系统有足够可用的Free Page。
4. **MySQL实例正常关闭时**。关闭时需要把缓冲区中的数据持久化到磁盘。

> Innodb 的三种Page和链表的设计，保证了我们需要的热数据常驻在内存，及时淘汰不需要的数据，提升了我们的查询速度，同时不同的刷脏策略也提高了我们的恢复速度，保证了数据安全。

#### 7. 索引失效场景

1. 破坏最左原则。
2. 使用函数计算。 
3. 隐式转换。
4. 表达式放在等号左边。

#### 8. 主备延迟问题及解决




## 参考链接

1. <a target="_blank" href="https://zhuanlan.zhihu.com/p/102802249">Innodb Buffer Pool的三种Page和链表</a>
2. <a target="_blank" href="https://zhuanlan.zhihu.com/p/65811829">[玩转MySQL之十]InnoDB Buffer Pool详解</a>
